##### 1、初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来替代。

##### 2、当用于内置类型的变量是，列表初始化形式有一个重要的特点：如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

##### 3、如果是内置类型变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量（全局变量）被初始化为0，定义在函数体内部的变量（局部变量）将不被初始化。

##### 4、变量能且只能被定义一次，但是可以被多次声明。

##### 5、引用

- 引用类型的初始值必须是一个对象。
- 引用必须初始化，在定义引用的时候把它和初始值绑定在一起，而不是将初始值拷贝给引用，一旦初始化完成后引用就会和初始值对象一直绑定在一起，无法令引用重新绑定到一个另外的对象上，所以引用必须被初始化。
- 引用不是对象，它只是为一个已经存在的对象起了一个别名。
- 除了两种例外情况以为，引用的类型要和与之绑定的对象严格匹配。
- 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

##### 6、指针

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针生命周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋予初始值，和其他内置类型一样，在块作用域内定义的指针如果没有赋初值，也将拥有一个不确定的值。
- 指针只能指向和自己类型相同的对象。
- 指针值应属于下面四种状态之一：
  1. 指向一个对象。
  2. 指向紧邻对象所占空间的下一个位置。
  3. 空指针，意味着指针没有指向任何对象。
  4. 无效指针，也就是上述情况之外的其他值。
- c++11 中引入nullptr表示空指针。
- 把int变量直接赋给指针是错误的操作，即使int变量的值恰好为0也不行（类型不匹配 int* 和 int）。
- void* 是一种特殊的指针类型，可用于存放任意对象的地址，一个void*指针存放着一个地址。
- 不能直接操作void* 指针所指的对象，因为我们无法确定，该对象的类型。
- 引用不是对象，所以不能用指针指向引用；但是指针是对象，所以可以有指向指针的引用。
- 面对一条比较复杂的指针或引用的声明语句是，从右向左阅读有助于弄清楚它的真实含义。

##### 7、const限定符

- const修饰的变量必须初始化。
- 默认情况下const对象仅在文件内有效。
- 初始化常量引用是允许任意表达式作为初始值，只要该表达式的结果可以转换成引用的类型即可，尤其允许为一个常量引用绑定一个非常量的对象、字面值、甚至是一个表达式。
- const引用可能引用一个非const的对象，因此const引用仅仅表示不能通过该引用修改对象，但是不代表引用所指的对象不能被修改。
- 指向常量的指针不能用于修改其所指对象的值，想要存放常量对象的地址，只能使用指向常量的指针。
- 常量指针必须初始化。
- 顶层const：表示指针本身是一个常量。
- 底层const：表示指针所指的对象是一个常量。

##### 8、常量表达式：是指值不会改变并且在编译过程就能得到计算结果的表达式。

##### 9、constexpr变量

- C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
- 声明为从constexpr的变量一定是一个常量，而且必须用常量表达式来初始化。
- 不能使用普通函数作为constexpr变量的初始值，但是可以用constexpr函数去初始化constexpr变量。
- 对于声明constexpr时用到的类型必须有所限制，可以使用”字面值“。
- 在constexpr声明中如果定义一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

##### 10、类型别名

- 传统方法是使用关键**typedef** 

  `typedef long long LL; // LL是long long的同义词`

- C++11新标准中使用**别名声明**来定义类型的别名

  `using LL = long long;`

##### 11、auto 类型说明符

- C++11新标准引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型，auto让编译器通过出数值来推算变量的类型。

- 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型使得更符合初始化规则。

- auto一般会忽略掉顶层const，同时底层const则会保留下来。

- 如果希望推断出的auto类型是一个顶层const，则须明确指出

  ```c++
  int i = 0;
  cosnt int ci = i;
  const auto f = ci // ci的类型推演类型是int，f是const int 
  ```

##### 12、decltype类型指示符

- decltype的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

  ```c++
  cosnt int ci = 0;
  decltype(ci) x = 0;
  ```

- decltype(*p)的结果类型就是int& 而不是int。

- **decltype((value)) 的结果永远都是引用，而decltype(value) 结果只有当value本身就是一个引用时才是 引用**

##### 13、头文件保护符

- ''#define" 指令把一个名字设定为预处理变量。

- "#ifdef" 当且仅当变量以定义时为真。
- "#ifndef" 当且仅当变量未定义时为真。
- "#endif" 指令结束。

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

